=head1 Context

Z<context_philosophy>

X<context>

In spoken languages, the meaning of a word or phrase depends on how you use it;
the local I<context> of other grammatical constructs helps clarify the intent.
For example, the inappropriate pluralization of "Please give me one
hamburgers!" sounds wrong (the pluralization of the noun differs from the
amount), just as the incorrect gender of "la gato" (the article is feminine,
but the noun is masculine) makes native speakers chuckle. Some words do double
duty; one sheep is a sheep just as two sheep are also sheep and you program a
program.

Perl uses context to express how to treat a piece of data. This governs the
I<amount> of data as well as the I<kind> of data. For example, several Perl
operations produce different behaviors when you expect zero, one, or many
results. A specific construct in Perl may do something different if you write
"Do this, but I don't care about any results" compared to "Do this and give me
multiple results." Other operations allow you to specify whether you expect to
work with numeric, textual, or true or false data.

You must keep context in mind when you read Perl code. Every expression is part
of a larger context. You may find yourself slapping your forehead after a long
debugging session when you discover that your assumptions about context were
incorrect. If instead you're aware of context, your code will be more
correct--and cleaner, flexible, and more concise.

=head2 Void, Scalar, and List Context

Z<amount_context>

X<context; amount>
X<amount context>

I<Amount context> governs I<how many> items you expect an operation to produce.
Think of subject-verb number agreement in English. Even without knowing the
formal description of this principle, you probably understand the error in the
sentence "Perl are a fun language." (In terms of amount context, you could say
that the verb "are" expects a plural noun or noun phrase.) In Perl, the number
of items you request influences how many you receive.

X<void context>
X<context; void>

Suppose the function (L<functions>) called C<find_chores()> sorts your
household todo list in order of priority. The number of chores you expect to
read from your list influences what the function produces. If you expect
nothing, you're just pretending to be busy. If you expect one task, you have
something to do for the next fifteen minutes. If you have a burst of energy on
a free weekend, you could get all of your chores.

Why does context matter? A context-aware function can examine its calling
context and decide how much work it must do. When you call a function and never
use its return value, you've used I<void context>:

=begin programlisting

    find_chores();

=end programlisting

X<context; scalar>
X<scalar context>

Assigning the function's return value to a single item (L<scalars>) enforces
I<scalar context>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<list context>
X<context; list>

Assigning the results of calling the function to an array (L<arrays>) or a
list, or using it in a list, evaluates the function in I<list context>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();

    # list of results passed to a function
    process_list_of_results( find_chores() );

=end programlisting

The parentheses in the second line of the previous example group the two
variable declarations (L<lexical_scope>) into a single unit so that assignment
assigns to both of the variables. A single-item list is still a list, though.
You could also correctly write:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting

.... in which case the parentheses tell Perl parser that you intend list
context for the single variable C<$single_element>. This is subtle, but now
that you know about it, the difference of amount context between these two
statements should be obvious:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Lists propagate list context to the expressions they contain. This often
confuses novices until they understand it. Both of these calls to
C<find_chores()> occur in list context:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results = (
        cheap_operation     => $cheap_results,
        expensive_operation => find_chores(), # OOPS!
    );

=end programlisting

X<builtins; C<scalar>>

Yes, initializing a hash (L<hashes>) with a list of values imposes list context
on C<find_chores>. Use the C<scalar> operator to impose scalar context:

=begin programlisting

    my %results = (
        cheap_operation     => $cheap_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Again, context can help you determine how much work a function should do. In
void context, C<find_chores()> may legitimately do nothing. In scalar context,
it can find only the most important task. In list context, it must sort and
return the entire list.

=head2 Numeric, String, and Boolean Context

Z<value_contexts>

X<value context>
X<context; value>

Perl's other context--I<value context>--influences how Perl interprets a piece
of data. Perl can figure out if you have a number or a string and convert data
between the two types. In exchange for not having to declare explicitly what
I<type> of data a variable contains or a function produces, Perl's value
contexts provide hints about how to treat that data.

X<builtins; C<eq>>

Perl will coerce values to specific proper types (L<coercion>) depending on the
operators you use. For example, the C<eq> operator tests that two values
contain equivalent string values:

=begin programlisting

    say "Catastrophic crypto fail!" if $alice eq $bob;

=end programlisting

You may have had a baffling experience where you I<know> that the strings are
different, but they still compare the same:

=begin programlisting

    my $alice = 'alice';
    say "Catastrophic crypto fail!" if $alice == 'Bob';

=end programlisting

X<string context>
X<numeric context>
X<context; string>
X<context; numeric>

X<builtins; C<==>>

The C<eq> operator treats its operands as strings by enforcing I<string
context> on them, but the C<==> operator imposes I<numeric context>. In numeric
context, both strings evaluate to C<0> (L<numeric_coercion>). Be sure to use
the proper operator for your desired value context.

X<boolean context>
X<context; boolean>

I<Boolean context> occurs when you use a value in a conditional statement. In
the previous examples, C<if> evaluated the results of the C<eq> and C<==>
operators in boolean context.

X<context; explicit>

In rare circumstances, you may not be able to use the appropriate operator to
enforce value context. To force a numeric context, add zero to a variable. To
force a string context, concatenate a variable with the empty string. To force
a boolean context, double up the negation operator:

=begin programlisting

    my $numeric_x =  0 + $x;  # forces numeric context
    my $stringy_x = '' . $x;  # forces string  context
    my $boolean_x =    !!$x;  # forces boolean context

=end programlisting

Value contexts are easier to identify than amount contexts. Once you know which
operators provide which contexts (L<operator_types>), you'll rarely make
mistakes.
