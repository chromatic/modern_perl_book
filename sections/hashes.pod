=head1 Hashes

Z<hashes>

X<hashes>

A I<hash> is an aggregate data structure which associates string keys with
scalar values. Just as the name of a variable corresponds to something which
holds a value, so a hash key refers to something which contains a value. Think
of a hash like a contact list: use the names of your friends to look up their
birthdays. Other languages call hashes I<tables>, I<associative arrays>,
I<dictionaries>, and I<maps>.

Hashes have two important properties: they store one scalar per unique key and
they provide no specific ordering of keys. Keep that latter property in mind.
Though it has always been true in Perl, it's very, very true in modern Perl.

=head2 Declaring Hashes

Z<declaring_hashes>

X<hashes; declaring>
X<C<%>; sigil>
X<sigils; C<%>>

Hashes use the C<%> sigil. Declare a lexical hash with:

=begin programlisting

    my %favorite_flavors;

=end programlisting

A hash starts out empty. You could write C<my %favorite_flavors = ();>, but
that's redundant.

X<C<$>; sigil>
X<sigils; C<$>>

Hashes use the scalar sigil C<$> when accessing individual elements and curly
braces C<{ }> for keyed access:

=begin programlisting

    my %favorite_flavors;
    $favorite_flavors{Gabi}    = 'Dark chocolate raspberry';
    $favorite_flavors{Annette} = 'French vanilla';

=end programlisting

Assign a list of keys and values to a hash in a single expression:

=begin programlisting

    my %favorite_flavors = (
        'Gabi',    'Dark chocolate raspberry',
        'Annette', 'French vanilla',
    );

=end programlisting

X<<< C<< => >>; fat comma operator >>>
X<<< operators; C<< => >> >>>

Hashes store pairs of keys and values. Perl will warn you if you assign an odd
number of elements to a hash. Idiomatic Perl often uses the I<fat comma>
operator (C<< => >>) to associate values with keys, as it makes the pairing
more visible:

=begin programlisting

    my %favorite_flavors = (
        Gabi    B<< => >> 'Dark chocolate raspberry',
        Annette B<< => >> 'French vanilla',
    );

=end programlisting

The fat comma operator acts like the regular comma I<and> also automatically
quotes the previous bareword (L<barewords>). The C<strict> pragma will not warn
about such a bareword--and if you have a function with the same name as a hash
key, the fat comma will I<not> call the function:

=begin programlisting

    sub name { 'Leonardo' }

    my %address = (
        name => '1123 Fib Place'
    );

=end programlisting

The key of this hash will be C<name> and not C<Leonardo>. To call the function,
make the function call explicit:

=begin programlisting

    my %address = (
        B<name()> => '1123 Fib Place'
    );

=end programlisting

=begin notetip

Hash assignment occurs in list context. Any function called in a hash
assignment will default to list context without an explicit C<scalar()>
coercion.

=end notetip

You may occasionally see C<undef %hash>, but that's a little ugly. Assign an
empty list to empty a hash:

=begin programlisting

    %favorite_flavors = ();

=end programlisting

=head2 Hash Indexing

X<hashes; values>

To access an individual hash value, use the I<keyed access> syntax:

=begin programlisting

    my $address = $addressesB<{$name}>;

=end programlisting

In this example, C<$name> contains a string which is also a key of the hash.
As with accessing an individual element of an array, the hash's sigil has
changed from C<%> to C<$> to indicate keyed access to a scalar value.

You may also use string literals as hash keys. Perl quotes barewords
automatically according to the same rules as fat commas:

=begin programlisting

    # auto-quoted
    my $address = $addresses{Victor};

    # needs quoting; not a valid bareword
    my $address = $addresses{B<'>Sue-LinnB<'>};

    # function call needs disambiguation
    my $address = $addresses{get_nameB<()>};

=end programlisting

=begin tip Don't Quote Me

Novices often always quote string literal hash keys, but experienced developers
elide the quotes whenever possible. If you code this way, you can use the rare
presence of quotes to indicate that you're doing something special on purpose.

=end tip

Even Perl builtins get the autoquoting treatment:

=begin programlisting

    my %addresses = (
        Leonardo => '1123 Fib Place',
        Utako    => 'Cantor Hotel, Room 1',
    );

    sub get_address_from_name {
        return $addresses{B<+>shift};
    }

=end programlisting

The unary plus (L<unary_coercions>) turns what would be a bareword (C<shift>)
subject to autoquoting rules into an expression. As this implies, you can use
an arbitrary expression--not only a function call--as the key of a hash:

=begin programlisting

    # don't actually I<do> this though
    my $address = $addresses{reverse 'odranoeL'};

    # interpolation is fine
    my $address = $addresses{"$first_name $last_name"};

    # so are method calls
    my $address = $addresses{ $user->name };

=end programlisting

Hash keys can only be strings. Anything that evaluates to a string is an
acceptable hash key. Perl will go so far as to coerce (L<coercion>) an
expression into a string. For example, if you use an object as a hash key,
you'll get the stringified version of that object instead of the object itself:

=begin programlisting

    for my $isbn (@isbns) {
        my $book = Book->fetch_by_isbn( $isbn );

        # unlikely to do what you want
        $books{$book} = $book->price;
    }

=end programlisting

That stringified hash will look something like C<Book=HASH(0x222d148)>. C<Book>
refers to the class name. C<HASH> identifies the object as a blessed reference.
C<0x22d148> is a number used to identify the object (more precisely: it's the
location of the data structure representing the hash in memory, so it's neither
quite random nor unique).

=head2 Hash Key Existence

X<builtins; C<exists>>
X<hashes; C<exists>>

The C<exists> operator returns a boolean value to indicate whether a hash
contains the given key:

=begin programlisting

    my %addresses = (
        Leonardo => '1123 Fib Place',
        Utako    => 'Cantor Hotel, Room 1',
    );

    say "Have Leonardo's address" if exists $addresses{Leonardo};
    say "Have Warnie's address"   if exists $addresses{Warnie};

=end programlisting

Using C<exists> instead of accessing the hash key directly avoids two problems.
First, it does not check the boolean nature of the hash I<value>; a hash key
may exist with a value even if that value evaluates to a boolean false
(including C<undef>):

=begin programlisting

    my %false_key_value = ( 0 => '' );
    ok %false_key_value,
       'hash containing false key & value should evaluate to a true value';

=end programlisting

Second, C<exists> avoids autovivification (L<autovivification>) within nested
data structures (L<nested_data_structures>).

X<builtins; C<defined>>

If a hash key exists, its value may be C<undef>. Check that with C<defined>:

=begin programlisting

    $addresses{Leibniz} = undef;

    say "Gottfried lives at $addresses{Leibniz}"
        if exists  $addresses{Leibniz}
        && defined $addresses{Leibniz};

=end programlisting

=head2 Accessing Hash Keys and Values

X<hashes; C<keys>>
X<builtins; C<keys>>

Hashes are aggregate variables, but their pairwise nature is unique. Perl
allows you to iterate over a hash's keys, its values, or pairs of its keys and
values. The C<keys> operator produces a list of hash keys:

=begin programlisting

    for my $addressee (keys %addresses) {
        say "Found an address for $addressee!";
    }

=end programlisting

X<hashes; C<values>>
X<builtins; C<values>>

The C<values> operator produces a list of hash values:

=begin programlisting

    for my $address (values %addresses) {
        say "Someone lives at $address";
    }

=end programlisting

X<hashes; C<each>>
X<builtins; C<each>>

The C<each> operator produces a list of two-element key/value lists:

=begin programlisting

    while (my ($addressee, $address) = each %addresses) {
        say "$addressee lives at $address";
    }

=end programlisting

Unlike arrays, hash elements have no obvious ordering. The ordering depends on
the internal implementation of the hash, the particular version of Perl you are
using, the size of the hash, and a random factor. Even so, the order of hash
items is consistent between C<keys>, C<values>, and C<each>. Modifying the hash
may change the order, but you can rely on that order if the hash remains the
same. However, even if two hashes have the I<same> keys and values, you cannot
rely on the iteration order between those hashes being the same. They may have
been constructed differently or have had elements removed. Since Perl 5.18,
even if you build two hashes in the same way, you cannot depend on the same
iteration order between them.

Read the previous paragraph again. You'll be glad you did.

Each hash has only a I<single> iterator for the C<each> operator. You cannot
reliably iterate over a hash with C<each> more than once; if you begin a new
iteration while another is in progress, the former will end prematurely and the
latter will begin partway through the iteration. Beware not to call any
function which may itself try to iterate over the hash with C<each>.

This is rarely a problem, but it's not fun to debug. Reset a hash's iterator
with C<keys> or C<values> in void context:

=begin programlisting

    # reset hash iterator
    keys %addresses;

    while (my ($addressee, $address) = each %addresses) {
        ...
    }

=end programlisting

=head2 Hash Slices

X<hashes; slicing>
X<slices; hash>

A I<hash slice> is a list of keys or values of a hash indexed in a single
operation. To initialize multiple elements of a hash at once:

=begin programlisting

    my %cats;
    @cats{qw( Jack Brad Mars Grumpy )} = (1) x 4;

=end programlisting

This is equivalent to the initialization:

=begin programlisting

    my %cats = map { $_ => 1 } qw( Jack Brad Mars Grumpy );

=end programlisting

Note however that the hash slice assignment can also add to the existing
contents of the hash.

X<C<@>; sigil>
X<sigils; C<@>>

Hash slices also allow you to retrieve multiple values from a hash in a single
operation. As with array slices, the sigil of the hash changes to C<@> to
indicate list context. The use of the curly braces indicates keyed access and
makes the fact that you're working with a hash unambiguous:

=begin programlisting

    my @buyer_addresses = @addresses{ @buyers };

=end programlisting

Hash slices make it easy to merge two hashes:

=begin programlisting

    my %addresses        = ( ... );
    my %canada_addresses = ( ... );

    @addresses{ keys %canada_addresses } = values %canada_addresses;

=end programlisting

This is equivalent to looping over the contents of C<%canada_addresses>
manually, but is much shorter. Note that this relies on the iteration order of
the hash remaining consistent between C<keys> and C<values>. Perl guarantees
this, but only because these operations occur on the same hash with no
modifications to that hash between the C<keys> and C<values> operations.

What if the same key occurs in both hashes? The hash slice approach always
I<overwrites> existing key/value pairs in C<%addresses>. If you want other
behavior, looping is more appropriate.

=head2 The Empty Hash

An empty hash contains no keys or values. It evaluates to a false value in a
boolean context. A hash which contains at least one key/value pair evaluates to
a true value in boolean context even if all of the keys or all of the values or
both would themselves evaluate to boolean false values.

=begin programlisting

    use Test::More;

    my %empty;
    ok ! %empty, 'empty hash should evaluate false';

    my %false_key = ( 0 => 'true value' );
    ok %false_key, 'hash containing false key should evaluate to true';

    my %false_value = ( 'true key' => 0 );
    ok %false_value, 'hash containing false value should evaluate to true';

    done_testing();

=end programlisting

In scalar context, a hash evaluates to a string which represents the ratio of
full buckets in the hash--internal details about the hash implementation that
you can safely ignore. In a boolean scalar context, this ratio evaluates to a
false value, so remember I<that> instead of the ratio details.

In list context, a hash evaluates to a list of key/value pairs similar to the
list produced by the C<each> operator. However, you I<cannot> iterate over this
list the same way you can iterate over the list produced by C<each>. This loop
will never terminate:

=begin programlisting

    # infinite loop for non-empty hashes
    while (my ($key, $value) = %hash) {
        ...
    }

=end programlisting

You I<can> loop over the list of keys and values with a C<for> loop, but the
iterator variable will get a key on one iteration and its value on the next,
because Perl will flatten the hash into a single list of interleaved keys and
values.

=head2 Hash Idioms

X<hashes; finding uniques>

Because each key exists only once in a hash, assigning the same key to a hash
multiple times stores only the most recent value associated with that key. This
behavior has advantages! For example, to find unique elements of a list:

=begin programlisting

    my %uniq;
    undef @uniq{ @items };
    my @uniques = keys %uniq;

=end programlisting

Using C<undef> with a hash slice sets the values of the hash to C<undef>. This
idiom is the cheapest way to perform set operations with a hash.

X<hashes; counting items>

Hashes are useful for counting elements, such as IP addresses in a log file:

=begin programlisting

    my %ip_addresses;

    while (my $line = <$logfile>) {
        chomp $line;
        my ($ip, $resource) = analyze_line( $line );
        $ip_addresses{$ip}++;
        ...
    }

=end programlisting

The initial value of a hash value is C<undef>. The postincrement operator
(C<++>) treats that as zero. This in-place modification of the value increments
an existing value for that key. If no value exists for that key, Perl creates a
value (C<undef>) and immediately increments it to one, as the numification of
C<undef> produces the value 0.

X<hashes; caching>
X<orcish maneuver>

This strategy provides a useful caching mechanism to store the result of an
expensive operation with little overhead:

=begin programlisting

    {
        my %user_cache;

        sub fetch_user {
            my $id = shift;
            $user_cache{$id} //= create_user($id);
            return $user_cache{$id};
        }
    }

=end programlisting

X<defined-or>
X<C<//>; infix operator>
X<operators; C<//>>
X<operators; defined-or>

This I<orcish maneuver> (or-cache) returns the value from the hash, if it
exists. Otherwise, it calculates, caches, and returns the value. The defined-or
assignment operator (C<//=>) evaluates its left operand. If that operand is not
defined, the operator assigns to the lvalue the value of its right operand. In
other words, if there's no value in the hash for the given key, this function
will call C<create_user()> with the key and update the hash.

You may see older code which uses the boolean-or assignment operator (C<||=>)
for this purpose. Remember though that some valid values evaluate as false in a
boolean context. The defined-or operator usually makes more sense, as it tests
for definedness instead of truthiness.

X<hashes; named parameters>

If your function takes several arguments, use a slurpy hash
(L<parameter_slurping>) to gather key/value pairs into a single hash as named
function arguments:

=begin programlisting

    sub make_sundae {
        my %parameters = @_;
        ...
    }

    make_sundae( flavor  => 'Lemon Burst',
                 topping => 'cookie bits' );

=end programlisting

This approach allows you to set default values:

=begin programlisting

    sub make_sundae {
        my %parameters           = @_;
        B<$parameters{flavor}    //= 'Vanilla';>
        B<$parameters{topping}   //= 'fudge';>
        B<$parameters{sprinkles} //= 100;>
        ...
    }

=end programlisting

... or include them in the hash initialization, as latter assignments take
precedence over earlier assignments:

=begin programlisting

    sub make_sundae {
        my %parameters = (
            B<< flavor    => 'Vanilla', >>
            B<< topping   => 'fudge', >>
            B<< sprinkles => 100, >>
            @_,
        );
        ...
    }

=end programlisting

=head2 Locking Hashes

Z<locked_hashes>

X<hashes; locked>
X<C<Hash::Util>>
X<C<Hash::Util>; C<lock_keys>>
X<C<Hash::Util>; C<lock_value>>
X<C<Hash::Util>; C<lock_hash>>
X<C<Hash::Util>; C<unlock_hash>>

As hash keys are barewords, they offer little typo protection compared to the
function and variable name protection offered by the C<strict> pragma. The
little-used core module C<Hash::Util> can make hashes safer.

To prevent someone from accidentally adding a hash key you did not intend
(whether as a typo or from untrusted user input), use the C<lock_keys()>
function to restrict the hash to its current set of keys. Any attempt to add a
new key to the hash will raise an exception. Similarly you can lock or unlock
the existing value for a given key in the hash (C<lock_value()> and
C<unlock_value()>) and make or unmake the entire hash read-only with
C<lock_hash()> and C<unlock_hash()>.

This is lax security; anyone can use the appropriate unlocking functions to
work around the locking. Yet it does protect against typos and other unintended
accidents.
