=head1 Names

Z<names>

X<names>
X<identifiers>

I<Names> (or I<identifiers>) are everywhere in Perl programs: you choose them
for variables, functions, packages, classes, and even filehandles. Valid Perl
names all begin with a letter or an underscore and may optionally include any
combination of letters, numbers, and underscores. When the C<utf8> pragma
(L<unicode>) is in effect, you may use any UTF-8 word characters in
identifiers. These are valid Perl identifiers:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;
    sub anAwkwardName3;

    # with use utf8; enabled
    package Ingy::DE<ouml>t::Net;

=end programlisting

These are invalid Perl identifiers:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<symbolic lookups>

I<Names exist primarily for your benefit as a programmer>. These rules apply
only to literal names which appear in your source code, such as C<sub
fetch_pie> or C<my $waffleiron>.

Only Perl's parser enforces the rules about identifier names. You may also
refer to entities with names generated at runtime or provided as input to a
program. These I<symbolic lookups> provide flexibility at the expense of
safety. Invoking functions or methods indirectly or looking up symbols in a
namespace lets you bypass Perl's parser. Symbolic lookups can produce confusing
code. As Mark Jason Dominus
recommendsN<U<http://perl.plover.com/varvarname.html>>, prefer a hash
(L<hashes>) or nested data structure (L<nested_data_structures>) over variables
named, for example, C<$recipe1>, C<$recipe2>, and so on.

=head2 Variable Names and Sigils

X<variables; names>
X<scalar variables>
X<variables; scalars>
X<scalars>
X<arrays>
X<variables; arrays>
X<hashes>
X<variables; hashes>
X<sigil>

I<Variable names> always have a leading I<sigil> (a symbol) which indicates the
type of the variable's value. I<Scalar variables> (L<scalars>) use the dollar
sign (C<$>). I<Array variables> (L<arrays>) use the at sign (C<@>).  I<Hash
variables> (L<hashes>) use the percent sign (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Sigils separate variables into different namespaces. It's possible--though
confusing--to declare multiple variables of the same name with different types:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Perl won't get confused, though humans will.

X<variant sigils>

The sigil of a variable changes depending on its use; this change is called
I<variant sigils>. As context determines how many items you expect from an
operation or what type of data you expect to get, so the sigil governs how you
manipulate the data of a variable. For example, use the scalar sigil (C<$>) to
access a single element of an array or a hash:

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

The parallel with amount context is important. Using a scalar element of an
aggregate as an I<lvalue> (the target of an assignment; on the I<l>eft side of
the C<=> character) imposes scalar context (L<context_philosophy>) on the
I<rvalue> (the value assigned; on the I<r>ight side of the C<=> character).

X<slices>

Similarly, accessing multiple elements of a hash or an array--an operation
known as I<slicing>--uses the at symbol (C<@>) and imposes list context--even
if the list itself has zero or one elements:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

Given Perl's variant sigils, the most reliable way to determine the type of a
variable--scalar, array, or hash--is to observe the operations performed on it.
Arrays support indexed access through square brackets. Hashes support keyed
access through curly brackets. Scalars have neither.

=head2 Namespaces

X<fully-qualified name>
X<namespaces>

Perl allows you to collect similar functions and variables into their own
unique named spaces--I<namespaces> (L<packages>). A namespace is collection of
symbols grouped under a globally unique name. Perl allows multi-level
namespaces, with names joined by double colons (C<::>).
C<DessertShop::IceCream> refers to a logical collection of related variables
and functions, such as C<scoop()> and C<pour_hot_fudge()>.

Within a namespace, you may use the short name of its members. Outside of the
namespace, you must refer to a member by its I<fully-qualified name>. Within
C<DessertShop::IceCream>, C<add_sprinkles()> refers to the same function as
does C<DessertShop::IceCream::add_sprinkles()> outside of the namespace.

Standard identifier rules apply to package names. By convention, the Perl core
reserves lowercase package names for core pragmas (L<pragmas>), such as
C<strict> and C<warnings>. User-defined packages all start with uppercase
letters. This is a policy enforced primarily by community guidelines.

All namespaces in Perl are globally visible. When Perl looks up a symbol in
C<DessertShop::IceCream::Freezer>, it looks in the C<main::> symbol table for a
symbol representing the C<DessertShop::> namespace, in that namespace for the
C<IceCream::> namespace, and so on. Yet C<Freezer::> is visible from outside of
the C<IceCream::> namespace. The nesting of the former within the latter is
only a storage mechanism; it implies nothing about relationships between parent
and child or sibling packages.

Only you as a programmer can make I<logical> relationships between entities
obvious--by choosing good names and organizing them well.
