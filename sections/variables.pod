=head1 Variables

Z<variables>
X<variable>

A I<variable> in Perl is a storage location for a value (L<values>). While a
trivial program may manipulate values directly, most programs work with
variables. Think of this like algebra: you manipulate symbols to describe
formulas. It's easier to explain the Pythagorean theorem in terms of the
variables C<a>, C<b>, and C<c> than by intuiting its principle by producing a
long list of valid values.

=head2 Variable Scopes

Z<variable_scopes>

X<variables; scope>
X<scope>
X<builtins; C<package>>

Your ability to access a variable within your program depends on the variable's
scope (L<scope>). Most variables in modern Perl programs have a lexical scope
(L<lexical_scope>) governed by the syntax of the program as written.  Most
lexical scopes are either the contents of blocks delimited by curly braces
(C<{> and C<}>) or entire files. I<Files> themselves provide their own lexical
scopes, such that a C<package> declaration on its own does not create a new
scope:

=begin programlisting

    package Store::Toy;

    my $discount = 0.10;

    package Store::Music;

    # $discount still visible
    say "Our current discount is $discount!";

=end programlisting

X<builtins; C<package>; BLOCK>

You may also provide a block to the C<package> declaration. Because this
introduces a new block, it also provides a new lexical scope:

=begin programlisting

    package Store::Toy {
        my $discount = 0.10;
    }

    package Store::Music {
        # $discount not visible
    }

    package Store::BoardGame;

    # $discount still not visible

=end programlisting

=head2 Variable Sigils

Z<sigils>

X<variables; sigils>
X<sigils>

The sigil of the variable in a declaration determines the type of the variable:
scalar, array, or hash. The sigil used when I<accessing> a variable varies
depending on what you do to the variable. For example, you declare an array as
C<@values>. Access the first element--a single value--of the array with
C<$values[0]>. Access a list of values from the array with C<@values[ @indices
]>. The sigil you use determines amount context in an lvalue situation:

=begin programlisting

    # imposes lvalue context on some_function()
    @values[ @indexes ] = some_function();

=end programlisting

... or gets coerced in an rvalue situation:

=begin programlisting

    # list evaluated to final element in scalar context
    my $element = @values[ @indices ];

=end programlisting

=head2 Anonymous Variables

X<anonymous variables>
X<variables; anonymous>

Perl variables do not I<require> names. Names exist to help you, the
programmer, keep track of an C<$apple>, C<@barrels>, or C<%cookie_recipes>.
Variables created I<without> literal names in your source code are
I<anonymous>. The only way to access anonymous variables is by reference
(L<references>).

=head2 Variables, Types, and Coercion

X<variables; types>
X<variables; container type>
X<variables; value type>

This relationship between variable types, sigils, and context is essential to
your understanding of Perl.

A Perl variable represents both a value (a dollar cost, available pizza
toppings, the names and numbers of guitar stores) and the container which
stores that value. Perl's type system deals with I<value types> and I<container
types>. While a variable's I<container type>--scalar, array, or hash--cannot
change, Perl is flexible about a variable's value type. You may store a string
in a variable in one line, append to that variable a number on the next, and
reassign a reference to a function (L<function_references>) on the third,
though this is a great way to confuse yourself.

Performing an operation on a variable which imposes a specific value type may
cause coercion (L<coercion>) of the variable's existing value type.

For example, the documented way to determine the number of entries in an array
is to evaluate that array in scalar context (L<context_philosophy>). Because a
scalar variable can only ever contain a scalar, assigning an array (the rvalue)
to a scalar (the lvalue) imposes scalar context on the operation, and an array
evaluated in scalar context produces the number of elements in the array:

=begin programlisting

    my $count = @items;

=end programlisting
