=head1 State versus Closures

Z<state>

Closures (L<closures>) use lexical scope (L<scope>) to control access to
lexical variables--even with named functions:

=begin programlisting

    {
        my $safety = 0;

        sub enable_safety  { $safety = 1 }
        sub disable_safety { $safety = 0 }

        sub do_something_awesome {
            return if $safety;
            ...
        }
    }

=end programlisting

All three functions encapsulate that shared state without exposing the lexical
variable outside of their shared scope. This idiom works well for cases where
multiple functions access that lexical, but it's clunky when only one function
does. Suppose every hundredth ice cream parlor customer gets free sprinkles:

=begin programlisting

    my $cust_count = 0;

    sub serve_customer {
        $cust_count++;
        my $order = shift;

        add_sprinkles($order) if $cust_count % 100 == 0;
        ...
    }

=end programlisting

X<state>
X<builtins; C<state>>

This approach I<works>, but creating a new outer lexical scope for a single
function is a little bit noisy. The C<state> builtin allows you to declare a
lexically scoped variable with a value that persists between invocations:

=begin programlisting

    sub serve_customer {
        B<state $cust_count = 0;>
        $cust_count++;

        my $order = shift;
        add_sprinkles($order)
            if ($cust_count % 100 == 0);

        ...
    }

=end programlisting

C<state> also works within anonymous functions:

=begin programlisting

    sub make_counter {
        return sub {
             B<state $count = 0;>
             return $count++;
         }
    }

=end programlisting

... though there are few obvious benefits to this approach.

=head1 State versus Pseudo-State

In old versions of Perl, a named function could close over its previous lexical
scope by abusing a quirk of implementation. Using a postfix conditional which
evaluates to false with a C<my> declaration avoided I<reinitializing> a lexical
variable to C<undef> or its initialized value.

Now any use of a postfix conditional expression modifying a lexical variable
declaration produces a deprecation warning. It's too easy to write
inadvertently buggy code with this technique; use C<state> instead where
available, or a true closure otherwise. Rewrite this idiom when you encounter
it:

=begin programlisting

    sub inadvertent_state {
        # my $counter  = 1 if 0; # DEPRECATED; don't use
        state $counter = 1;      # prefer

        ...
    }

=end programlisting

You may only initialize a state variable with a scalar value. If you need to
keep track of an aggregate, use a hash or array reference (L<references>).
